// Некоторые числа обладают забавными свойствами. Например:

// 89 --> 8¹ + 9² = 89 * 1

// 695 --> 6² + 9³ + 5⁴= 1390 = 695 * 2

// 46288 --> 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51

// Дано положительное целое число n, записанное как abcd ... (a, b, c, d ... являются цифрами) и положительное целое число p

// мы хотим найти положительное целое число k, если оно существует, такое, что сумма цифр числа n, приведенных к последовательным степеням p, равна k * n .
// Другими словами:

// Существует ли целое число k, такое как : (a ^ p + b ^ (p + 1) + c ^(p + 2) + d ^ (p + 3) + ...) = n * k

// Если это так, мы вернем k, если нет, вернем -1.

// Примечание: n и p всегда будут заданы как строго положительные целые числа.

// digPow(89, 1) should return 1 since 8¹ + 9² = 89 = 89 * 1
// digPow(92, 1) should return -1 since there is no k such as 9¹ + 2² equals 92 * k
// digPow(695, 2) should return 2 since 6² + 9³ + 5⁴= 1390 = 695 * 2
// digPow(46288, 3) should return 51 since 4³ + 6⁴+ 2⁵ + 8⁶ + 8⁷ = 2360688 = 46288 * 51




function digPow(nume, per){
    let a = nume.toString().split('');
    let b = 0;
    for(let i = per, k=0; i < a.length , k < a.length ; i++, k++){
        b += a[k]**i
    }
  
    return Number.isInteger(b/nume) ? b/nume : -1;
   
  }



  console.log(digPow(961, 10)) 

